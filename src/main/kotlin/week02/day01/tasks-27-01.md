### Task 1 - `map` (квадраты)
**Дано:** `List<Int>`  
**Сделать:** получить список квадратов чисел.

**Ожидаемый результат:** `List<Int>` той же длины.

---

### Task 2 - `filter` (чётные)
**Дано:** `List<Int>`  
**Сделать:** оставить только чётные числа.

**Ожидаемый результат:** `List<Int>` меньшей или равной длины.

---

### Task 3.1 - `flatMap` + `filter` (вложенные списки чисел)
**Дано:** `List<List<Int>>`  
**Сделать:**
1) развернуть в `List<Int>` через `flatMap`
2) отфильтровать по условию (в моём решении: `number > digitCount(number)`)

> Примечание: добавлена функция `digitCount()` для подсчёта количества цифр в числе.

---

### Task 3.2 - `filter` + `map` (строки)
**Дано:** `List<String>`  
**Сделать:**
1) оставить строки длиной > 3
2) преобразовать в uppercase

**Ожидаемый результат:** `List<String>`

---

### Task 4 - `data class` + `filter` + `map` (пользователи)
**Модель:** `User(name, age)`  
**Дано:** `List<User>`  
**Сделать:** получить список имён пользователей, которые старше 18 (или 18+ — по решению).

**Ожидаемый результат:** `List<String>`

---

### Task 5 - `flatMap` (группы студентов)
**Модель:** `Group(students: List<String>)`  
**Дано:** `List<Group>`  
**Сделать:** получить один общий список всех студентов.

**Ожидаемый результат:** `List<String>`

---

### Task 6 - `flatMap` + “сохранение контекста” + `filter`
**Модели:**
- `Order(id, items: List<Item>)`
- `Item(name, price)`

**Дано:** `List<Order>`  
**Сделать:**
1) развернуть все `items` в один список
2) **сохранить `order.id`** для каждого item (контекст родителя)
3) отфильтровать товары с `price > 100`

**Результат:** `List<Pair<Int, Item>>`, где `first` = `orderId`, `second` = `Item`.